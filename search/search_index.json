{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Oliver Twist DAG Auditor oliver-twist is a dag auditing tool that audits the DBT DAG and generates a summary report. Getting Started To get started, install the package $ pip install olivertwist and then run it by passing it your dbt manifest JSON olivertwist check manifest.json This will report any failures to the console, and also in HTML format in a directory called target . You can optionally auto-open the report in a browser with: olivertwist check manifest.json --browser Full options are available with: olivertwist check --help Configuration All rules are enabled by default. To change this you need a configuration file called olivertwist.yml in the same directory you are running olivertwist . An example configuration is shown below: version : '1.0' universal : - id : no-rejoin-models enabled : false - id : no-disabled-models enabled : true There is a command to help you generate the config automatically: olivertwist config This will show all the available rules and allow you to toggle the ones that you want to enforce.","title":"Homepage"},{"location":"#oliver-twist","text":"DAG Auditor oliver-twist is a dag auditing tool that audits the DBT DAG and generates a summary report.","title":"Oliver Twist"},{"location":"#getting-started","text":"To get started, install the package $ pip install olivertwist and then run it by passing it your dbt manifest JSON olivertwist check manifest.json This will report any failures to the console, and also in HTML format in a directory called target . You can optionally auto-open the report in a browser with: olivertwist check manifest.json --browser Full options are available with: olivertwist check --help","title":"Getting Started"},{"location":"#configuration","text":"All rules are enabled by default. To change this you need a configuration file called olivertwist.yml in the same directory you are running olivertwist . An example configuration is shown below: version : '1.0' universal : - id : no-rejoin-models enabled : false - id : no-disabled-models enabled : true There is a command to help you generate the config automatically: olivertwist config This will show all the available rules and allow you to toggle the ones that you want to enforce.","title":"Configuration"},{"location":"rules/","text":"No disabled models There are disabled scripts. If you have disabled a script that you no longer require, you should probably delete it. Assuming that you have your dbt scripts under version control, you can always retrieve the script if you need it in future. No orphaned models There are model(s) that have become disconnected and have no resolvable dependencies. graph LR A --> B --> C Orphan This can be caused by: Hard-coded references to scripts The use of target_project() to reference a script A script that compiles to no content (e.g. an empty file or a macro) When referencing dependencies, you should use: source() for sources (https://docs.getdbt.com/docs/using-sources) ref() for models (https://docs.getdbt.com/docs/ref) e.g.: SELECT * FROM {{ source ( 'source_name' , 'table_name' ) }} SELECT * FROM {{ ref ( 'script_name' ) }} Single source per staging model There are staging script(s) that have multiple source inputs. graph LR src1[Source A] & src2[Source B] --> Staging When a staging script depends on a source, it should be a one-to-one mapping. This allows for any renaming or casting from the source system to be done in one place. No rejoin models These models are taking part in rejoins. graph LR Source --> Staging --> m1[Mart A] --> m2[Mart B] Staging --> m2 The example above shows that Staging is rejoined into Mart B . This probably means that something is missing in Mart A . No references outside of its own staging area There are staging model(s) referencing a staging model that belongs in a different area graph LR subgraph stg2[Staging 2] src_b --> stg_b end subgraph stg1[Staging 1] src_a --> stg_a end subgraph stg3[Staging 3] src_b --This is bad!--> stg_c end If you want to cross areas, this should be done at mart level. No references to marts from staging There are staging model(s) referencing a mart model. graph LR Source --> Staging --> Marts Marts --This is bad!--> Staging Data should be flowing from source centric to business centric areas like so: graph LR Source --> Staging --> Marts No references to source from marts There are mart model(s) referencing a source. graph LR Source --> Staging --> Marts Source --This is bad!--> m2[Mart B] Data should be flowing from source centric to business centric areas like so: graph LR Source --> Staging --> Marts No owner on physical models There are physical models without a designated owner. Physical models consist of the following: - sources - table materialization - view materialization - incremental materialization To ensure ownership and proper cataloguing of data is preserved, fill in all your physical models with the owner tag as described in the Dbt reference","title":"Rules"},{"location":"rules/#no-disabled-models","text":"There are disabled scripts. If you have disabled a script that you no longer require, you should probably delete it. Assuming that you have your dbt scripts under version control, you can always retrieve the script if you need it in future.","title":"No disabled models"},{"location":"rules/#no-orphaned-models","text":"There are model(s) that have become disconnected and have no resolvable dependencies. graph LR A --> B --> C Orphan This can be caused by: Hard-coded references to scripts The use of target_project() to reference a script A script that compiles to no content (e.g. an empty file or a macro) When referencing dependencies, you should use: source() for sources (https://docs.getdbt.com/docs/using-sources) ref() for models (https://docs.getdbt.com/docs/ref) e.g.: SELECT * FROM {{ source ( 'source_name' , 'table_name' ) }} SELECT * FROM {{ ref ( 'script_name' ) }}","title":"No orphaned models"},{"location":"rules/#single-source-per-staging-model","text":"There are staging script(s) that have multiple source inputs. graph LR src1[Source A] & src2[Source B] --> Staging When a staging script depends on a source, it should be a one-to-one mapping. This allows for any renaming or casting from the source system to be done in one place.","title":"Single source per staging model"},{"location":"rules/#no-rejoin-models","text":"These models are taking part in rejoins. graph LR Source --> Staging --> m1[Mart A] --> m2[Mart B] Staging --> m2 The example above shows that Staging is rejoined into Mart B . This probably means that something is missing in Mart A .","title":"No rejoin models"},{"location":"rules/#no-references-outside-of-its-own-staging-area","text":"There are staging model(s) referencing a staging model that belongs in a different area graph LR subgraph stg2[Staging 2] src_b --> stg_b end subgraph stg1[Staging 1] src_a --> stg_a end subgraph stg3[Staging 3] src_b --This is bad!--> stg_c end If you want to cross areas, this should be done at mart level.","title":"No references outside of its own staging area"},{"location":"rules/#no-references-to-marts-from-staging","text":"There are staging model(s) referencing a mart model. graph LR Source --> Staging --> Marts Marts --This is bad!--> Staging Data should be flowing from source centric to business centric areas like so: graph LR Source --> Staging --> Marts","title":"No references to marts from staging"},{"location":"rules/#no-references-to-source-from-marts","text":"There are mart model(s) referencing a source. graph LR Source --> Staging --> Marts Source --This is bad!--> m2[Mart B] Data should be flowing from source centric to business centric areas like so: graph LR Source --> Staging --> Marts","title":"No references to source from marts"},{"location":"rules/#no-owner-on-physical-models","text":"There are physical models without a designated owner. Physical models consist of the following: - sources - table materialization - view materialization - incremental materialization To ensure ownership and proper cataloguing of data is preserved, fill in all your physical models with the owner tag as described in the Dbt reference","title":"No owner on physical models"}]}